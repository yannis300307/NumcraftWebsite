!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).Upsilon=t()}(this,function(){"use strict";function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var t,r,i,n,a,s,o,c,l,d,u,f,g,h;function m(){if(r)return t;r=1;class e{static get DETACH(){return 0}static get DNLOAD(){return 1}static get UPLOAD(){return 2}static get GETSTATUS(){return 3}static get CLRSTATUS(){return 4}static get GETSTATE(){return 5}static get ABORT(){return 6}static get appIDLE(){return 0}static get appDETACH(){return 1}static get dfuIDLE(){return 2}static get dfuDNLOAD_SYNC(){return 3}static get dfuDNBUSY(){return 4}static get dfuDNLOAD_IDLE(){return 5}static get dfuMANIFEST_SYNC(){return 6}static get dfuMANIFEST(){return 7}static get dfuMANIFEST_WAIT_RESET(){return 8}static get dfuUPLOAD_IDLE(){return 9}static get dfuERROR(){return 10}static get STATUS_OK(){return 0}static findDeviceDfuInterfaces(e){let t=[];for(let r of e.configurations)for(let e of r.interfaces)for(let i of e.alternates)if(254===i.interfaceClass&&1===i.interfaceSubclass&&(1===i.interfaceProtocol||2===i.interfaceProtocol)){let n={configuration:r,interface:e,alternate:i,name:i.interfaceName};t.push(n)}return t}static findAllDfuInterfaces(){return navigator.usb.getDevices().then(t=>{let r=[];for(let i of t){let t=e.findDeviceDfuInterfaces(i);for(let n of t)r.push(new e.Device(i,n))}return r})}static parseDeviceDescriptor(e){return{bLength:e.getUint8(0),bDescriptorType:e.getUint8(1),bcdUSB:e.getUint16(2,!0),bDeviceClass:e.getUint8(4),bDeviceSubClass:e.getUint8(5),bDeviceProtocol:e.getUint8(6),bMaxPacketSize:e.getUint8(7),idVendor:e.getUint16(8,!0),idProduct:e.getUint16(10,!0),bcdDevice:e.getUint16(12,!0),iManufacturer:e.getUint8(14),iProduct:e.getUint8(15),iSerialNumber:e.getUint8(16),bNumConfigurations:e.getUint8(17)}}static parseConfigurationDescriptor(t){let r=new DataView(t.buffer.slice(9)),i=e.parseSubDescriptors(r);return{bLength:t.getUint8(0),bDescriptorType:t.getUint8(1),wTotalLength:t.getUint16(2,!0),bNumInterfaces:t.getUint8(4),bConfigurationValue:t.getUint8(5),iConfiguration:t.getUint8(6),bmAttributes:t.getUint8(7),bMaxPower:t.getUint8(8),descriptors:i}}static parseInterfaceDescriptor(e){return{bLength:e.getUint8(0),bDescriptorType:e.getUint8(1),bInterfaceNumber:e.getUint8(2),bAlternateSetting:e.getUint8(3),bNumEndpoints:e.getUint8(4),bInterfaceClass:e.getUint8(5),bInterfaceSubClass:e.getUint8(6),bInterfaceProtocol:e.getUint8(7),iInterface:e.getUint8(8),descriptors:[]}}static parseFunctionalDescriptor(e){return{bLength:e.getUint8(0),bDescriptorType:e.getUint8(1),bmAttributes:e.getUint8(2),wDetachTimeOut:e.getUint16(3,!0),wTransferSize:e.getUint16(5,!0),bcdDFUVersion:e.getUint16(7,!0)}}static parseSubDescriptors(t){let r,i=t,n=[],a=!1;for(;i.byteLength>2;){let t=i.getUint8(0),s=i.getUint8(1),o=new DataView(i.buffer.slice(0,t));if(4===s)r=e.parseInterfaceDescriptor(o),a=254===r.bInterfaceClass&&1===r.bInterfaceSubClass,n.push(r);else if(a&&33===s){let t=e.parseFunctionalDescriptor(o);n.push(t),r.descriptors.push(t)}else{let e={bLength:t,bDescriptorType:s,data:o};n.push(e),r&&r.descriptors.push(e)}i=new DataView(i.buffer.slice(t))}return n}}return e.Device=class{constructor(e,t){this.device_=e,this.settings=t,this.intfNumber=t.interface.interfaceNumber,this.dnload=this.download,this.clrStatus=this.clearStatus}logDebug(e){console.debug(e)}logInfo(e){console.info(e)}logWarning(e){console.warn(e)}logError(e){console.error(e)}logProgress(e,t){void 0===t?this.logDebug(e):this.logDebug(e+"/"+t)}async open(){await this.device_.open();const e=this.settings.configuration.configurationValue;null!==this.device_.configuration&&this.device_.configuration.configurationValue===e||await this.device_.selectConfiguration(e);const t=this.settings.interface.interfaceNumber;this.device_.configuration.interfaces[t].claimed||await this.device_.claimInterface(t);const r=this.settings.alternate.alternateSetting;let i=this.device_.configuration.interfaces[t];null!==i.alternate&&i.alternate.alternateSetting===r||await this.device_.selectAlternateInterface(t,r)}async close(){try{await this.device_.close()}catch(e){console.log(e)}}readDeviceDescriptor(){return this.device_.controlTransferIn({requestType:"standard",recipient:"device",request:6,value:256,index:0},18).then(e=>"ok"===e.status?Promise.resolve(e.data):Promise.reject(e.status))}async readStringDescriptor(e,t){void 0===t&&(t=0);const r={requestType:"standard",recipient:"device",request:6,value:768|e,index:t};var i=await this.device_.controlTransferIn(r,1);if("ok"===i.status){const e=i.data.getUint8(0);if("ok"===(i=await this.device_.controlTransferIn(r,e)).status){const r=(e-2)/2;let n=[];for(let e=0;e<r;e++)n.push(i.data.getUint16(2+2*e,!0));return 0===t?n:String.fromCharCode.apply(String,n)}}throw new Error(`Failed to read string descriptor ${e}: ${i.status}`)}async readInterfaceNames(){let t={},r=new Set;for(let i=0;i<this.device_.configurations.length;i++){const n=await this.readConfigurationDescriptor(i);let a=e.parseConfigurationDescriptor(n),s=a.bConfigurationValue;t[s]={};for(let e of a.descriptors)4===e.bDescriptorType&&(e.bInterfaceNumber in t[s]||(t[s][e.bInterfaceNumber]={}),t[s][e.bInterfaceNumber][e.bAlternateSetting]=e.iInterface,e.iInterface>0&&r.add(e.iInterface))}let i={};for(let e of r)try{i[e]=await this.readStringDescriptor(e,1033)}catch(t){console.log(t),i[e]=null}for(let e in t)for(let r in t[e])for(let n in t[e][r]){const a=t[e][r][n];t[e][r][n]=i[a]}return t}readConfigurationDescriptor(e){const t=512|e;return this.device_.controlTransferIn({requestType:"standard",recipient:"device",request:6,value:t,index:0},4).then(e=>{if("ok"===e.status){let r=e.data.getUint16(2,!0);return this.device_.controlTransferIn({requestType:"standard",recipient:"device",request:6,value:t,index:0},r)}return Promise.reject(e.status)}).then(e=>"ok"===e.status?Promise.resolve(e.data):Promise.reject(e.status))}requestOut(e,t,r=0){return this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:e,value:r,index:this.intfNumber},t).then(e=>"ok"===e.status?Promise.resolve(e.bytesWritten):Promise.reject(e.status),e=>Promise.reject("ControlTransferOut failed: "+e))}requestIn(e,t,r=0){return this.device_.controlTransferIn({requestType:"class",recipient:"interface",request:e,value:r,index:this.intfNumber},t).then(e=>"ok"===e.status?Promise.resolve(e.data):Promise.reject(e.status),e=>(console.error(e),Promise.reject("ControlTransferIn failed: "+e)))}detach(){return this.requestOut(e.DETACH,void 0,1e3)}async waitDisconnected(e){let t=this,r=this.device_;return new Promise(function(i,n){let a;e>0&&(a=setTimeout(n,e)),navigator.usb.addEventListener("disconnect",function n(s){s.device===r&&(e>0&&clearTimeout(a),t.disconnected=!0,navigator.usb.removeEventListener("disconnect",n),s.stopPropagation(),i(t))})})}download(t,r){return this.requestOut(e.DNLOAD,t,r)}upload(t,r){return this.requestIn(e.UPLOAD,t,r)}clearStatus(){return this.requestOut(e.CLRSTATUS)}getStatus(){return this.requestIn(e.GETSTATUS,6).then(e=>Promise.resolve({status:e.getUint8(0),pollTimeout:16777215&e.getUint32(1,!0),state:e.getUint8(4)}),e=>Promise.reject("DFU GETSTATUS failed: "+e))}getState(){return this.requestIn(e.GETSTATE,1).then(e=>Promise.resolve(e.getUint8(0)),e=>Promise.reject("DFU GETSTATE failed: "+e))}abort(){return this.requestOut(e.ABORT)}async abortToIdle(){await this.abort();let t=await this.getState();if(t===e.dfuERROR&&(await this.clearStatus(),t=await this.getState()),t!==e.dfuIDLE)throw new Error("Failed to return to idle state after abort: state "+t.state)}async do_upload(e,t=1/0,r=0){let i,n,a=r,s=[],o=0;this.logInfo("Copying data from DFU device to browser"),this.logProgress(0);do{n=Math.min(e,t-o),i=await this.upload(n,a++),this.logDebug("Read "+i.byteLength+" bytes"),i.byteLength>0&&(s.push(i),o+=i.byteLength),Number.isFinite(t)?this.logProgress(o,t):this.logProgress(o)}while(o<t&&i.byteLength===n);return o===t&&await this.abortToIdle(),this.logInfo(`Read ${o} bytes`),new Blob(s,{type:"application/octet-stream"})}async poll_until(t){let r=await this.getStatus(),i=this;function n(e){return new Promise(function(t,r){i.logDebug("Sleeping for "+e+"ms"),setTimeout(t,e)})}for(;!t(r.state)&&r.state!==e.dfuERROR;)await n(r.pollTimeout),r=await this.getStatus();return r}poll_until_idle(e){return this.poll_until(t=>t===e)}async do_download(t,r,i){let n=0,a=r.byteLength,s=0;for(this.logInfo("Copying data from browser to DFU device"),this.logProgress(n,a);n<a;){const i=a-n,o=Math.min(i,t);let c,l=0;try{l=await this.download(r.slice(n,n+o),s++),this.logDebug("Sent "+l+" bytes"),c=await this.poll_until_idle(e.dfuDNLOAD_IDLE)}catch(e){throw new Error("Error during DFU download: "+e)}if(c.status!==e.STATUS_OK)throw new Error(`DFU DOWNLOAD failed state=${c.state}, status=${c.status}`);this.logDebug("Wrote "+l+" bytes"),n+=l,this.logProgress(n,a)}this.logDebug("Sending empty block");try{await this.download(new ArrayBuffer([]),s++)}catch(e){throw new Error("Error during final DFU download: "+e)}if(this.logInfo("Wrote "+n+" bytes"),this.logInfo("Manifesting new firmware"),i){let t;try{if(t=await this.poll_until(t=>t===e.dfuIDLE||t===e.dfuMANIFEST_WAIT_RESET),t.state===e.dfuMANIFEST_WAIT_RESET&&this.logDebug("Device transitioned to MANIFEST_WAIT_RESET even though it is manifestation tolerant"),t.status!==e.STATUS_OK)throw new Error(`DFU MANIFEST failed state=${t.state}, status=${t.status}`)}catch(e){if(!e.endsWith("ControlTransferIn failed: NotFoundError: Device unavailable.")&&!e.endsWith("ControlTransferIn failed: NotFoundError: The device was disconnected."))throw new Error("Error during DFU manifest: "+e);this.logWarning("Unable to poll final manifestation status")}}else try{let e=await this.getStatus();this.logDebug(`Final DFU status: state=${e.state}, status=${e.status}`)}catch(e){this.logDebug("Manifest GET_STATUS poll error: "+e)}try{await this.device_.reset()}catch(e){if("NetworkError: Unable to reset the device."!==e&&"NotFoundError: Device unavailable."!==e&&"NotFoundError: The device was disconnected."!==e)throw new Error("Error during reset for manifestation: "+e);this.logDebug("Ignored reset error")}}},t=e}function w(){if(s)return a;s=1;const e=m(),t=function(){if(n)return i;n=1;const e=m();class t extends e{static get GET_COMMANDS(){return 0}static get SET_ADDRESS(){return 33}static get ERASE_SECTOR(){return 65}static parseMemoryDescriptor(e){const t=e.indexOf("/");if(!e.startsWith("@")||-1===t)throw new Error(`Not a DfuSe memory descriptor: "${e}"`);const r=e.substring(1,t).trim(),i=e.substring(t);let n=[];const a={" ":1,B:1,K:1024,M:1048576};let s,o=/\/\s*(0x[0-9a-fA-F]{1,8})\s*\/(\s*[0-9]+\s*\*\s*[0-9]+\s?[ BKM]\s*[abcdefg]\s*,?\s*)+/g;for(;s=o.exec(i);){let e,t=/([0-9]+)\s*\*\s*([0-9]+)\s?([ BKM])\s*([abcdefg])\s*,?\s*/g,r=parseInt(s[1],16);for(;e=t.exec(s[0]);){let t={},i=parseInt(e[1],10),s=parseInt(e[2])*a[e[3]],o=e[4].charCodeAt(0)-"a".charCodeAt(0)+1;t.start=r,t.sectorSize=s,t.end=r+s*i,t.readable=!!(1&o),t.erasable=!!(2&o),t.writable=!!(4&o),n.push(t),r+=s*i}}return{name:r,segments:n}}}return t.Device=class extends e.Device{constructor(e,r){super(e,r),this.memoryInfo=null,this.startAddress=NaN,r.name&&(this.memoryInfo=t.parseMemoryDescriptor(r.name))}async dfuseCommand(t,r,i){void 0===r&&void 0===i&&(r=0,i=1);const n={0:"GET_COMMANDS",33:"SET_ADDRESS",65:"ERASE_SECTOR"};let a=new ArrayBuffer(i+1),s=new DataView(a);if(s.setUint8(0,t),1===i)s.setUint8(1,r);else{if(4!==i)throw new Error("Don't know how to handle data of len "+i);s.setUint32(1,r,!0)}try{await this.download(a,0)}catch(e){throw new Error("Error during special DfuSe command "+n[t]+":"+e)}if((await this.poll_until(t=>t!==e.dfuDNBUSY)).status!==e.STATUS_OK)throw new Error("Special DfuSe command "+n[t]+" failed")}getSegment(e){if(!this.memoryInfo||!this.memoryInfo.segments)throw new Error("No memory map information available");for(let t of this.memoryInfo.segments)if(t.start<=e&&e<t.end)return t;return null}getSectorStart(e,t){if(void 0===t&&(t=this.getSegment(e)),!t)throw new Error(`Address ${e.toString(16)} outside of memory map`);const r=Math.floor((e-t.start)/t.sectorSize);return t.start+r*t.sectorSize}getSectorEnd(e,t){if(void 0===t&&(t=this.getSegment(e)),!t)throw new Error(`Address ${e.toString(16)} outside of memory map`);const r=Math.floor((e-t.start)/t.sectorSize);return t.start+(r+1)*t.sectorSize}getFirstWritableSegment(){if(!this.memoryInfo||!this.memoryInfo.segments)throw new Error("No memory map information available");for(let e of this.memoryInfo.segments)if(e.writable)return e;return null}getMaxReadSize(e){if(!this.memoryInfo||!this.memoryInfo.segments)throw new Error("No memory map information available");let t=0;for(let r of this.memoryInfo.segments)if(r.start<=e&&e<r.end){if(!r.readable)return 0;t+=r.end-e}else if(r.start===e+t){if(!r.readable)break;t+=r.end-r.start}return t}async erase(e,r){let i=this.getSegment(e),n=this.getSectorStart(e,i);const a=this.getSectorEnd(e+r-1);let s=0;const o=a-n;for(o>0&&this.logProgress(s,o);n<a;){if(i.end<=n&&(i=this.getSegment(n)),!i.erasable){s=Math.min(s+i.end-n,o),n=i.end,this.logProgress(s,o);continue}const e=Math.floor((n-i.start)/i.sectorSize),r=i.start+e*i.sectorSize;this.logDebug(`Erasing ${i.sectorSize}B at 0x${r.toString(16)}`),await this.dfuseCommand(t.ERASE_SECTOR,r,4),n=r+i.sectorSize,s+=i.sectorSize,this.logProgress(s,o)}}async do_download(r,i,n){if(!this.memoryInfo||!this.memoryInfo.segments)throw new Error("No memory map available");this.logInfo("Erasing DFU device memory");let a=0,s=i.byteLength,o=this.startAddress;isNaN(o)?(o=this.memoryInfo.segments[0].start,this.logWarning("Using inferred start address 0x"+o.toString(16))):null===this.getSegment(o)&&this.logError(`Start address 0x${o.toString(16)} outside of memory map bounds`),await this.erase(o,s),this.logInfo("Copying data from browser to DFU device");let c=o;for(;a<s;){const n=s-a,o=Math.min(n,r);let l,d=0;try{await this.dfuseCommand(t.SET_ADDRESS,c,4),this.logDebug(`Set address to 0x${c.toString(16)}`),d=await this.download(i.slice(a,a+o),2),this.logDebug("Sent "+d+" bytes"),l=await this.poll_until_idle(e.dfuDNLOAD_IDLE),c+=o}catch(e){throw new Error("Error during DfuSe download: "+e)}if(l.status!==e.STATUS_OK)throw new Error(`DFU DOWNLOAD failed state=${l.state}, status=${l.status}`);this.logDebug("Wrote "+d+" bytes"),a+=d,this.logProgress(a,s)}if(this.logInfo(`Wrote ${a} bytes`),n){this.logInfo("Manifesting new firmware");try{await this.dfuseCommand(t.SET_ADDRESS,o,4),await this.download(new ArrayBuffer,2)}catch(e){throw new Error("Error during DfuSe manifestation: "+e)}try{await this.poll_until(t=>t===e.dfuMANIFEST)}catch(e){this.logError(e)}}}async do_upload(r,i){let n=this.startAddress;return isNaN(n)?(n=this.memoryInfo.segments[0].start,this.logWarning("Using inferred start address 0x"+n.toString(16))):null===this.getSegment(n)&&this.logWarning(`Start address 0x${n.toString(16)} outside of memory map bounds`),this.logInfo(`Reading up to 0x${i.toString(16)} bytes starting at 0x${n.toString(16)}`),await this.getState()!==e.dfuIDLE&&await this.abortToIdle(),await this.dfuseCommand(t.SET_ADDRESS,n,4),await this.abortToIdle(),await super.do_upload(r,i,2)}},i=t}();return a={DFU:e,DFUse:t}}function v(){if(c)return o;c=1;function e(e,t){if(!e&&!t)throw new Error("Please specify valid arguments for parameters a and b.");if(!t||0===t.length)return e;if(!e||0===e.length)return t;if(Object.prototype.toString.call(e)!==Object.prototype.toString.call(t))throw new Error("The types of the two arguments passed for parameters a and b do not match.");var r=new e.constructor(e.length+t.length);return r.set(e),r.set(t,e.length),r}return o=
/**
		 * Class to parse and reconstruct the numworks' internal storage.
		 * Only parses python scripts for now, ditches the rest.
		 * @TODO parse other things.
		 *
		 * @author Maxime "M4x1m3" FRIESS
		 * @license MIT
		 */
class{constructor(){this.magik=null,this.records=null}async __encodePyRecord(t){var r=new TextEncoder("utf-8").encode(t.code);return t.data=new Blob([e(new Uint8Array([t.autoImport?1:0]),e(r,new Uint8Array([0])))]),delete t.autoImport,delete t.code,t}__getRecordEncoders(){return{py:this.__encodePyRecord.bind(this)}}async __assembleStorage(t,r){const i=new TextEncoder;var n=new Uint8Array([186,221,11,238]);for(var a in t){var s=t[a],o=s.name+"."+s.type,c=e(i.encode(o),new Uint8Array([0])),l=e(c,new Uint8Array(await s.data.arrayBuffer()));if(l=e(new Uint8Array([255,255]),l),new DataView(l.buffer).setUint16(0,l.length,!0),n.length+l.length+2>r)throw console.error("Too much data!"),new Error("Too much data!");n=e(n,l)}return n=e(n,new Uint8Array([0,0])),new Blob([n])}async __encodeRecord(e){var t=this.__getRecordEncoders();return e.type in t&&(e=t[e.type](e)),e}async encodeStorage(e){var t=Object.assign({},this.records);for(var r in this.records)t[r]=await this.__encodeRecord(t[r]);return await this.__assembleStorage(t,e)}async __sliceStorage(e){var t=new DataView(await e.arrayBuffer());if(3135048686===t.getUint32(0,!1)){var r=4,i=[];do{var n=t.getUint16(r,!0);if(0===n)break;var a=this.__readString(t,r+2,n-2),s=e.slice(r+2+a.size,r+n),o={name:a.content.split(/\.(?=[^\.]+$)/)[0],type:a.content.split(/\.(?=[^\.]+$)/)[1],data:s};i.push(o),r+=n}while(0!==n&&r<e.size);return i}return{}}__readString(e,t,r){var i="",n=0;for(n=0;n<r||0===r;n++){var a=e.getUint8(t+n);if(0===a)break;i+=String.fromCharCode(a)}return{size:n+1,content:i}}async __parsePyRecord(e){var t=new DataView(await e.data.arrayBuffer());return e.autoImport=0!==t.getUint8(0),e.code=this.__readString(t,1,e.data.size-1).content,delete e.data,e}__getRecordParsers(){return{py:this.__parsePyRecord.bind(this)}}async __parseRecord(e){var t=this.__getRecordParsers();return e.type in t&&(e=t[e.type](e)),e}async parseStorage(e){var t=new DataView(await e.arrayBuffer());if(this.magik=3135048686===t.getUint32(0,!1),this.records={},this.magik)for(var r in this.records=await this.__sliceStorage(e),this.records)this.records[r]=await this.__parseRecord(this.records[r])}},o}function p(){if(f)return u;f=1;var e=w(),t=e.DFU,r=e.DFUse,i=v(),n=function(){if(d)return l;d=1;var e=w(),t=e.DFU,r=e.DFUse;return v(),l=
/**
		 * Class handling communication with a Numworks
		 * calculator in Recovery Mode using WebUSB and the WebDFU lib.
		 *
		 * @author Maxime "M4x1m3" FRIESS
		 * @license MIT
		 */
class{constructor(){this.device=null,this.transferSize=2048,this.manifestationTolerant=!1,this.autoconnectId=null}getModel(e=!0){var t=0;for(let e=0;e<this.device.memoryInfo.segments.length;e++)this.device.memoryInfo.segments[e].start>=134217728&&this.device.memoryInfo.segments[e].start<=135266303&&(t+=this.device.memoryInfo.segments[e].end-this.device.memoryInfo.segments[e].start);return 524288===t?"0110":1048576===t?"0100":"????"}async flashRecovery(e){this.device.startAddress=537067520,await this.device.clearStatus(),await this.device.do_download(this.transferSize,e,!0)}async __getDFUDescriptorProperties(e){return e.readConfigurationDescriptor(0).then(r=>{let i=t.parseConfigurationDescriptor(r),n=null,a=e.settings.configuration.configurationValue;if(i.bConfigurationValue===a)for(let e of i.descriptors)if(33===e.bDescriptorType&&e.hasOwnProperty("bcdDFUVersion")){n=e;break}return n?{WillDetach:!!(8&n.bmAttributes),ManifestationTolerant:!!(4&n.bmAttributes),CanUpload:!!(2&n.bmAttributes),CanDnload:!!(1&n.bmAttributes),TransferSize:n.wTransferSize,DetachTimeOut:n.wDetachTimeOut,DFUVersion:n.bcdDFUVersion}:{}},e=>{})}async detect(e,r){var i=this;navigator.usb.requestDevice({filters:[{vendorId:1155,productId:57105}]}).then(async r=>{let n=t.findDeviceDfuInterfaces(r);await i.__fixInterfaceNames(r,n),i.device=await i.__connect(new t.Device(r,n[0])),e()}).catch(e=>{r(e)})}async __connect(e){try{await e.open()}catch(e){throw e}let t={};try{t=await this.__getDFUDescriptorProperties(e)}catch(e){throw e}return t&&Object.keys(t).length>0&&(e.properties=t,this.transferSize=t.TransferSize,t.CanDnload&&(this.manifestationTolerant=t.ManifestationTolerant),256!==t.DFUVersion&&282!==t.DFUVersion||2!==e.settings.alternate.interfaceProtocol||(e=new r.Device(e.device_,e.settings)).memoryInfo&&e.memoryInfo.segments.unshift({start:536870912,sectorSize:1024,end:537133056,readable:!0,erasable:!1,writable:!0})),e.logDebug=console.log,e.logInfo=console.info,e.logWarning=console.warn,e.logError=console.error,e.logProgress=console.log,e}async __autoConnectDevice(e){let r=t.findDeviceDfuInterfaces(e.device_);return await this.__fixInterfaceNames(e.device_,r),await this.__connect(new t.Device(e.device_,r[0]))}autoConnect(e,r){var i=this;t.findAllDfuInterfaces().then(async t=>{let n=i.__findMatchingDevices(1155,57105,r,t);0!==n.length&&(this.stopAutoConnect(),this.device=await this.__autoConnectDevice(n[0]),await e())}),this.autoconnectId=setTimeout(this.autoConnect.bind(this,e,r),1e3)}stopAutoConnect(){null!==this.autoconnectId&&(clearTimeout(this.autoconnectId),this.autoconnectId=null)}async __fixInterfaceNames(e,r){if(r.some(e=>null===e.name)){let i=new t.Device(e,r[0]);await i.device_.open();let n=await i.readInterfaceNames();await i.close();for(let e of r)if(null===e.name){let t=e.configuration.configurationValue,r=e.interface.interfaceNumber,i=e.alternate.alternateSetting;e.name=n[t][r][i]}}}__findMatchingDevices(e,t,r,i){let n=[];for(let a of i)r?a.device_.serialNumber===r&&n.push(a):(!t&&e>0&&a.device_.vendorId===e||!e&&t>0&&a.device_.productId===t||e>0&&t>0&&a.device_.vendorId===e&&a.device_.productId===t)&&n.push(a);return n}async __retreiveStorage(e,t){return this.device.startAddress=e,await this.device.do_upload(this.transferSize,t+8)}async __flashStorage(e,t){this.device.startAddress=e,await this.device.do_download(this.transferSize,t,!1)}onUnexpectedDisconnect(e,t){null!==this.device&&null!==this.device.device_&&this.device.device_===e.device&&(this.device.disconnected=!0,t(e),this.device=null)}}}();
/**
		 * Class handling communication with a Numworks
		 * calculator using WebUSB and the WebDFU lib.
		 *
		 * @author Maxime "M4x1m3" FRIESS
		 * @license MIT
		 */
class a{constructor(){this.device=null,this.transferSize=2048,this.manifestationTolerant=!1,this.autoconnectId=null}getModel(e=!0){var t=0,r=0;for(let e=0;e<this.device.memoryInfo.segments.length;e++)this.device.memoryInfo.segments[e].start>=134217728&&this.device.memoryInfo.segments[e].start<=135266303&&(t+=this.device.memoryInfo.segments[e].end-this.device.memoryInfo.segments[e].start),this.device.memoryInfo.segments[e].start>=2415919104&&this.device.memoryInfo.segments[e].start<=2684354559&&(r+=this.device.memoryInfo.segments[e].end-this.device.memoryInfo.segments[e].start);if("Upsilon Bootloader"==this.device.device_.productName)return"0110";if("Upsilon Calculator"==this.device.device_.productName)return r?"0110":"0100";switch(""+this.device.device_.deviceVersionMajor+this.device.device_.deviceVersionMinor+this.device.device_.deviceVersionSubminor){case"120":return"0120";case"115":return"0115";case"110":return"0110"}return 65536===t||0===t?0===r?e?"????":"0110-0M":8388608===r||8192e3===r?"0110":16777216===r?e?"0110":"0110-16M":"????":1048576===t?0===r?"0100":8388608===r?e?"0100":"0100-8M":16777216===r?e?"0100":"0100-16M":"????":"????"}async flashInternal(e){this.device.startAddress=134217728,await this.device.do_download(this.transferSize,e,!0)}async flashExternal(e){this.device.startAddress=2415919104,await this.device.do_download(this.transferSize,e,!1)}async __getDFUDescriptorProperties(e){return e.readConfigurationDescriptor(0).then(r=>{let i=t.parseConfigurationDescriptor(r),n=null,a=e.settings.configuration.configurationValue;if(i.bConfigurationValue===a)for(let e of i.descriptors)if(33===e.bDescriptorType&&e.hasOwnProperty("bcdDFUVersion")){n=e;break}return n?{WillDetach:!!(8&n.bmAttributes),ManifestationTolerant:!!(4&n.bmAttributes),CanUpload:!!(2&n.bmAttributes),CanDnload:!!(1&n.bmAttributes),TransferSize:n.wTransferSize,DetachTimeOut:n.wDetachTimeOut,DFUVersion:n.bcdDFUVersion}:{}},e=>{})}async detect(e,r){var i=this;await navigator.usb.requestDevice({filters:[{vendorId:1155,productId:41617}]}).then(async r=>{let n=t.findDeviceDfuInterfaces(r);await i.__fixInterfaceNames(r,n),i.device=await i.__connect(new t.Device(r,n[0])),e()}).catch(e=>{r(e)})}async __connect(e){try{await e.open()}catch(e){throw e}let t={};try{t=await this.__getDFUDescriptorProperties(e)}catch(e){throw e}return t&&Object.keys(t).length>0&&(e.properties=t,this.transferSize=t.TransferSize,t.CanDnload&&(this.manifestationTolerant=t.ManifestationTolerant),256!==t.DFUVersion&&282!==t.DFUVersion||2!==e.settings.alternate.interfaceProtocol||(e=new r.Device(e.device_,e.settings)).memoryInfo&&(e.memoryInfo.segments.unshift({start:536870912,sectorSize:1024,end:537133056,readable:!0,erasable:!1,writable:!0}),e.memoryInfo.segments.unshift({start:603979776,sectorSize:1024,end:604241920,readable:!0,erasable:!1,writable:!0}))),e.logDebug=console.log,e.logInfo=console.info,e.logWarning=console.warn,e.logError=console.error,e.logProgress=console.log,e}__readFString(e,t,r){for(var i="",n=0;n<r;n++){var a=e.getUint8(t+n);if(0===a)break;i+=String.fromCharCode(a)}return i}__parseKernelHeader(e){var t=new DataView(e),r={};const i=[4027433182,4276994270];let n=0;r.magik=t.getUint32(n,!1),n+=4;let a=!1;for(var s=0;s<i.length;s++)if(r.magik===i[s]){a=!0;break}return a?(r.version=this.__readFString(t,n,8),n+=8,r.commit=this.__readFString(t,n,8),n+=8,t.getUint32(n,!1)!==r.magik&&console.warn("PlatformInfo is not valid, end magic is not present at the end of the Kernel header"),r):(r.magik=!1,console.warn("No kernel magic"),r)}__parseCustomInfos(e,t){let r={},i=t;return r.omega={},r.omega.installed=3735928559===e.getUint32(i,!1),i+=4,r.omega.installed&&(r.omega.version=this.__readFString(e,i,16),i+=16,r.omega.user=this.__readFString(e,i,16),i+=16,3735928559!==e.getUint32(i,!1)&&console.warn("Omega Magic not present at end"),i+=4),r.upsilon={},r.upsilon.installed=1769173077===e.getUint32(i,!1),i+=4,r.upsilon.installed&&(r.upsilon.version=this.__readFString(e,i,16),i+=16,r.upsilon.osType=e.getUint32(i,!1),i+=4,2020704889==r.upsilon.osType?r.upsilon.official=!0:r.upsilon.official=!1,1769173077!==e.getUint32(i,!1)&&console.warn("Upsilon Magic not present at end"),i+=4),r}__parseUserlandHeader(e){var t=new DataView(e),r={};const i=[4027433182,4276994270];let n=0;r.magik=t.getUint32(n,!1),n+=4;let a=!1;for(var s=0;s<i.length;s++)if(r.magik===i[s]){a=!0;break}return a?(r.version=this.__readFString(t,n,8),n+=8,r.storage={},r.storage.address=t.getUint32(n,!0),n+=4,r.storage.size=t.getUint32(n,!0),n+=4,r.external={},r.external.flashStart=t.getUint32(n,!0),n+=4,r.external.flashEnd=t.getUint32(n,!0),n+=4,r.external.flashSize=r.external.flashEnd-r.external.flashStart,r.external.ramStart=t.getUint32(n,!0),n+=4,r.external.ramEnd=t.getUint32(n,!0),n+=4,r.external.ramSize=r.external.ramEnd-r.external.ramStart,t.getUint32(n,!1)!==r.magik&&(r.version<"22.0.0"&&console.warn("PlatformInfo is not valid, end magic is not present at the end of the Userland info for Epsilon 21, using Epsilon 22 struct"),r.epsilon={},r.epsilon.usernameStart=t.getUint32(n,!0),n+=4,r.epsilon.usernameEnd=t.getUint32(n,!0),n+=4,r.epsilon.usernameSize=r.epsilon.usernameEnd-r.epsilon.usernameStart),t.getUint32(n,!1)!==r.magik&&console.warn("PlatformInfo is not valid, end magic is not present at the end of the Kernel header"),n+=4,r={...r,...this.__parseCustomInfos(t,n)}):(r.magik=!1,console.warn("No usermand magic"),r)}async __parsePlatformInfo(e){var t=new DataView(e),r={};const i=[4027433182,4276994270];r.magik=t.getUint32(0,!1);let n=!1;for(var a=0;a<i.length;a++)if(r.magik===i[a]){n=!0;break}if(n||(r.magik=!1),r.magik)if(r.oldplatform=!(t.getUint32(28,!1)===r.magik),r.username="",r.omega={},r.oldplatform){r.omega.installed=t.getUint32(36,!1)===r.magik||3735928559===t.getUint32(44,!1)||3735928559===t.getUint32(60,!1),r.omega.installed&&(r.omega.version=this.__readFString(t,12,16),r.omega.user=""),r.version=this.__readFString(t,4,8);var s=0;t.getUint32(36,!1)===r.magik?s=8:t.getUint32(44,!1)===r.magik?s=16:t.getUint32(60,!1)===r.magik&&(s=32),r.commit=this.__readFString(t,12+s,8),r.storage={},r.storage.address=t.getUint32(20+s,!0),r.storage.size=t.getUint32(24+s,!0)}else r.version=this.__readFString(t,4,8),r.storage={},r.commit=this.__readFString(t,12,8),r.storage.address=t.getUint32(20,!0),r.storage.size=t.getUint32(24,!0),r={...r,...this.__parseCustomInfos(t,32)};else r.omega=!1;return r}__parseSlotInfo(e){var t=new DataView(e);let r={slot:{}};const i=3134975727;if(r.slot.magik=t.getUint32(0,!1)==i||(r.slot.magik=3689869064==t.getUint24(1,!1)),r.slot.magik){t.getUint32(12,!1)!==i&&console.warn("SlotInfo is not valid, end magic is not present at the end of the slot info"),r.slot.kernelHeader=t.getUint32(4,!0),r.slot.userlandHeader=t.getUint32(8,!0);const e={2415919104:"A",2420113408:"B",2417491968:"Khi"};let n=r.slot.kernelHeader-8;r.slot.name=e[n],null==r.slot.name&&console.warn("Slot name is not valid, the kernel header is not in the list")}return r}async getPlatformInfo(){let e=this.getModel(),t={};this.device.startAddress="0120"==e?603979776:536870912;let r=await this.device.do_upload(this.transferSize,100),i=this.__parseSlotInfo(await r.arrayBuffer());if(i.slot.magik){this.device.startAddress=i.slot.userlandHeader,r=await this.device.do_upload(this.transferSize,296),t=await this.__parseUserlandHeader(await r.arrayBuffer()),t.mode="bootloader",t.oldplatform=!1,this.device.startAddress=i.slot.kernelHeader,r=await this.device.do_upload(this.transferSize,100);let e=await this.__parseKernelHeader(await r.arrayBuffer());t={...t,...e}}else if(!t.magik){this.device.startAddress=134218180;const e=await this.device.do_upload(this.transferSize,296);return t=await this.__parsePlatformInfo(await e.arrayBuffer()),t.mode="legacy",t}return t.slot=i.slot,t}async __autoConnectDevice(e){let r=t.findDeviceDfuInterfaces(e.device_);return await this.__fixInterfaceNames(e.device_,r),e=await this.__connect(new t.Device(e.device_,r[0]))}autoConnect(e,r){var i=this;t.findAllDfuInterfaces().then(async t=>{let n=i.__findMatchingDevices(1155,41617,r,t);0!==n.length&&(this.stopAutoConnect(),this.device=await this.__autoConnectDevice(n[0]),await e())}),this.autoconnectId=setTimeout(this.autoConnect.bind(this,e,r),1e3)}stopAutoConnect(){null!==this.autoconnectId&&(clearTimeout(this.autoconnectId),this.autoconnectId=null)}async __fixInterfaceNames(e,r){if(r.some(e=>null===e.name)){let i=new t.Device(e,r[0]);await i.device_.open();let n=await i.readInterfaceNames();await i.close();for(let e of r)if(null===e.name){let t=e.configuration.configurationValue,r=e.interface.interfaceNumber,i=e.alternate.alternateSetting;e.name=n[t][r][i]}}}__findMatchingDevices(e,t,r,i){let n=[];for(let a of i)r?a.device_.serialNumber===r&&n.push(a):(!t&&e>0&&a.device_.vendorId===e||!e&&t>0&&a.device_.productId===t||e>0&&t>0&&a.device_.vendorId===e&&a.device_.productId===t)&&n.push(a);return n}async __retrieveStorage(e,t){return this.device.startAddress=e,await this.device.do_upload(this.transferSize,t+8)}async __flashStorage(e,t){this.device.startAddress=e,await this.device.do_download(this.transferSize,t,!1)}async installStorage(e,t){let r=await this.getPlatformInfo(),i=await e.encodeStorage(r.storage.size);await this.__flashStorage(r.storage.address,await i.arrayBuffer()),t()}async backupStorage(){let e=await this.getPlatformInfo(),t=await this.__retrieveStorage(e.storage.address,e.storage.size),r=new a.Storage;return await r.parseStorage(t),r}async crash(){this.device.startAddress=3735928559;try{await this.device.do_upload(this.transferSize,296);return!1}catch{return!0}}onUnexpectedDisconnect(e,t){null!==this.device&&null!==this.device.device_&&this.device.device_===e.device&&(this.device.disconnected=!0,t(e),this.device=null)}}return a.Recovery=n,a.Storage=i,u=a}return e(function(){if(h)return g;h=1;const e=p();return g=e}())});
//# sourceMappingURL=upsilon.bundle.js.map
